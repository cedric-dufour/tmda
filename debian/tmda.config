## TMDA Configuration
#  (this file must follow Python 3 syntax)

# DATADIR
# Top-level directory which TMDA uses to store its files and
# directories. TMDA should be free to create files and directories
# under DATADIR if need be.
#
# Examples:
# DATADIR = '/full/path/to/.tmda'
# DATADIR = '~/.tmda'
#
#DATADIR = '~/.tmda'

# MAIL_TRANSFER_AGENT
# Defines which mail transfer agent (MTA) software you are running.
# Possible choices are 'exim', 'postfix', 'qmail', or 'sendmail'.
#
MAIL_TRANSFER_AGENT = 'postfix'

# DELIVERY
# The default delivery instruction for successful messages, or TMDA's
# final delivery location. Only required if you are NOT running
# qmail. The default value for qmail users is "_qok_" which means
# exit(0) and proceed to the next instruction in the dot-qmail file.
#
# Delivery to qmail-style Maildirs, mboxrd-format mboxes, programs
# (pipe), and forward to an e-mail addresses are supported.
#
# Acceptable syntax and restrictions for delivery instructions are
# discussed in the "action" section of the TMDA Filter Specification
# (config-filter.html). Please read this documentation.
#
# Examples:
# DELIVERY = '~/Maildir/'
# DELIVERY = '~/Mailbox'
# DELIVERY = '/var/mail/jasonrm'
# DELIVERY = ':~/Mailbox'
# DELIVERY = ':/var/spool/mail/jasonrm'
# DELIVERY = '|/usr/bin/maildrop'
# DELIVERY = '|/usr/bin/procmail ~/.procmailrc-tmda'
# DELIVERY = 'me@new.job.com'
#
DELIVERY = '~/Maildir/'

# RECIPIENT_DELIMITER
# A single character which specifies the separator between user names
# and address extensions (e.g, user-ext).
# The default under qmail is '-', while the default for Sendmail and
# friends is likely '+'. The default for MMDF is '='.
# Make sure to add a corresponding 'recipient_delimiter' to Postfix.
#
RECIPIENT_DELIMITER = '-'

# ALLOW_MODE_640
# Set this variable to True if you want to allow a mode 640 CRYPT_KEY_FILE.
#
#ALLOW_MODE_640 = False

# MAIL_TRANSPORT
# Final delivery method for all outgoing mail (server and client).
#
# Possible values include:
#  'smtp'
#    Deliver messages by handing them off to an SMTP server (i.e,
#    smarthost). Be sure that the 'SMTPHOST' variable (see below) is
#    set correctly.
#  'sendmail'
#    Deliver messages via the command line interface to the sendmail
#    program (e.g, /usr/sbin/sendmail).
#
#MAIL_TRANSPORT = 'sendmail'

# SMTPHOST
# SMTP host and optional port, when MAIL_TRANSPORT is 'smtp'.
# If the hostname or IP address ends with a colon (':') followed by a
# number, that suffix will be stripped off and the number interpreted
# as the port number to use. Otherwise, the standard SMTP port (25)
# will be used.
#
# Examples:
# SMTPHOST = 'localhost'
# SMTPHOST = '172.16.78.20:2525'
# SMTPHOST = 'mailhost.company.com'
# SMTPHOST = 'mailhost.company.com:1234'
#
#SMTPHOST = 'localhost'

# SMTPAUTH_USERNAME
# The username to authenticate with if your SMTP server requires
# authentication. You must also define SMTPAUTH_PASSWORD if you use
# this option.
#
# Examples:
# SMTPAUTH_USERNAME = 'johndoe'
#
#SMTPAUTH_USERNAME = None

# SMTPAUTH_PASSWORD
# The password to authenticate with if your SMTP server requires
# authentication. You must also define SMTPAUTH_USERNAME if you use
# this option.
#
# Examples:
# SMTPAUTH_PASSWORD = '6Yu_9iKzs'
#
#SMTPAUTH_PASSWORD = None

# SMTPSSL
# Set this variable to True to put the SMTP connection in TLS (Transport
# Layer Security) mode. All SMTP commands that follow will be
# encrypted. Your Python's socket module must be compiled with SSL
# support.
#
#SMTPSSL = False

# SMTPSSL_KEYFILE
# When SMTPSSL is enabled, this is the optional name of a PEM
# formatted file that contains your private key.
#
#SMTPSSL_KEYFILE = None

# SMTPSSL_CERTFILE
# When SMTPSSL is enabled, this is the optional name of a PEM
# formatted certificate chain file. Warning: This does not do any
# certificate verification.
#
#SMTPSSL_CERTFILE = None

# SMTP_MAX_SESSIONS_PER_CONNECTION
# An integer specifying a ceiling on the number of SMTP sessions to
# perform on a single socket connection, when MAIL_TRANSPORT is
# 'smtp'. Some MTAs have limits. Set this to 0 to do as many
# as we like (i.e. your MTA has no limits). Set this to some number
# great than 0 and TMDA will close the SMTP connection and re-open it
# after this number of consecutive sessions.
#
#SMTP_MAX_SESSIONS_PER_CONNECTION = 0

# SENDMAIL_PROGRAM
# The path to the sendmail program, or sendmail compatibility
# interface when MAIL_TRANSPORT is 'sendmail'.
#
#SENDMAIL_PROGRAM = '/usr/sbin/sendmail'

# USEVIRTUALDOMAINS
# Set this variable to False if want to turn off TMDA's qmail virtualdomains
# support. This should obviously only be done if you are not running
# any qmail virtualdomains, but it will improve performance.
#
#USEVIRTUALDOMAINS = True

# VIRTUALDOMAINS
# virtualdomains defaults to /var/qmail/control/virtualdomains, but
# this lets you override it in case it is installed elsewhere. Used
# for virtualdomain processing in tmda-filter.
#
#VIRTUALDOMAINS = '/var/qmail/control/virtualdomains'

# BOUNCE_ENV_SENDER
# The envelope sender of a bounce message.
#
# Example:
# BOUNCE_ENV_SENDER = 'devnull@domain.dom'
#
#BOUNCE_ENV_SENDER = '<>'

# BARE_APPEND
# Filename to which a recipient's e-mail address should be
# automatically appended if the outgoing <action> is in the form
# 'bare=append'.
#
# Examples:
# BARE_APPEND = '/full/path/to/whitelist'
# BARE_APPEND = '~/.tmda/lists/whitelist'
#
#BARE_APPEND = None

# CONFIRM_ADDRESS
# An optional e-mail address to use for creating confirmation
# addresses. Normally, the recipient address is used, but in some
# virtual domain or forwarding scenarios, you may wish to have
# confirmation address be based on a fixed address regardless of the
# recipient address.
#
# Example:
# CONFIRM_ADDRESS = 'webmaster@domain.dom'
#
#CONFIRM_ADDRESS = None

# CONFIRM_APPEND
# Filename to which a sender's e-mail address should be automatically
# appended once they confirm a message. This can be used to implement
# "auto-whitelisting" functionality.
#
# Examples:
# CONFIRM_APPEND = '/full/path/to/whitelist'
# CONFIRM_APPEND = '~/.tmda/lists/whitelist'
#
#CONFIRM_APPEND = None

# CONFIRM_CC
# An optional e-mail address which will be sent a copy of any message
# that triggers a confirmation request.
#
# Example:
# CONFIRM_CC = 'jdoe-confirms@domain.dom'
#
#CONFIRM_CC = None

# CONFIRM_ACCEPT_NOTIFY
# Set this variable to False if you do not want to generate any
# confirmation acceptance notices. These are the notices returned to
# senders when they confirm their original message by e-mail. Their
# content is based on the confirm_accept.txt template.
#
#CONFIRM_ACCEPT_NOTIFY = True

# CONFIRM_ACCEPT_CC
# An optional e-mail address which will be sent a copy of the
# confirmation acceptance messages people send you.
#
# Example:
# CONFIRM_ACCEPT_CC = 'jdoe-confirm-replies@domain.dom'
#
#CONFIRM_ACCEPT_CC = None

# CONFIRM_MAX_MESSAGE_SIZE
# This is the largest size (in bytes) that a message can be before the
# its body is excluded from the confirmation request/acceptance
# notice. Set this to None to allow any size message.
#
#CONFIRM_MAX_MESSAGE_SIZE = 50000

# TEMPLATE_DIR
# Full path to a directory containing custom TMDA templates. Any
# templates found in this directory will be used, otherwise the
# default templates will be used.
#
# Examples:
# TEMPLATE_DIR = '/full/path/to/templates'
# TEMPLATE_DIR = '~/.tmda/templates'
#
TEMPLATE_DIR = '/etc/tmda/templates'

# TEMPLATE_DIR_MATCH_RECIPIENT
# Set this variable to True if you want to use specific templates for
# different recipient addresses. Be sure to set TEMPLATE_DIR as well.
#
# The TEMPLATE_DIR_MATCH_RECIPIENT feature enables TMDA to search for
# customized template files based on the recipient address. To continue
# with the example given for TEMPLATE_DIR_MATCH_SENDER, if a message
# arrives for foo-lists-guitar@bar.baz.de then TMDA will search for
# template files in the following directories:
#  foo-lists-guitars@bar.baz.de/
#  foo-lists@bar.baz.de/
#  foo@bar.baz.de/
#  bar.baz.de/
#  baz.de/
#  de/
#
# This example assumes that RECIPIENT_DELIMITER is set to '-'. This
# feature also works for *-confirm-* addresses.
#
# When both TEMPLATE_DIR_MATCH_RECIPIENT and TEMPLATE_DIR_MATCH_SENDER
# are enabled, the TEMPLATE_DIR_MATCH_RECIPIENT directories are searched
# after the sender directories.
#
#TEMPLATE_DIR_MATCH_RECIPIENT = False

# TEMPLATE_DIR_MATCH_SENDER
# Set this variable to True if you want to use sender specific template
# directory matching. Make sure you also have TEMPLATE_DIR set.
#
# With this feature enabled, TMDA will look for templates in a
# subdirectory of TEMPLATE_DIR that matches the sender address, and
# then increasingly general portions of the domain part of the address.
#
# For example, if mail arrives from foo@bar.baz.de, TMDA will look for
# templates in these subdirectories of TEMPLATE_DIR, in this order:
#  foo@bar.baz.de/
#  bar.baz.de/
#  baz.de/
#  de/
#
# If no sender based templates can be found, TEMPLATE_DIR itself and
# then the default locations will be tried.
#
#TEMPLATE_DIR_MATCH_SENDER = False

# TEMPLATE_EMAIL_HEADERS
# A list containing the names of headers in your templates that
# contain an e-mail address. This is necessary so that the e-mail
# address will avoid being RFC 2047 encoded when handling
# internationalized headers.
#
# Example:
# TEMPLATE_EMAIL_HEADERS = ['from', 'reply-to']
#
#TEMPLATE_EMAIL_HEADERS = ['from', 'reply-to']

# TEMPLATE_ENCODED_HEADERS
# A list containing the names of headers in your templates that might
# contain an RFC 2047 encoded string. This is necessary so that they
# can be decoded first when handling internationalized headers.
#
# Example:
# TEMPLATE_ENCODED_HEADERS = ['subject']
#
#TEMPLATE_ENCODED_HEADERS = ['subject']

# DATED_TEMPLATE_VARS
# Set this variable to True if you want to use "dated" address variables
# in your templates.
#
#DATED_TEMPLATE_VARS = False

# SENDER_TEMPLATE_VARS
# Set this variable to True if you want to use "sender" address variables
# in your templates.
#
#SENDER_TEMPLATE_VARS = False

# FILTER_INCOMING
# Filter file which controls how incoming messages are tagged.
# Look for the filter-file in the environment first.
#
#FILTER_INCOMING = '~/.tmda/filters/incoming'

# FILTER_OUTGOING
# Filter file which controls how outgoing messages are tagged.
# Look for the filter-file in the environment first.
#
#FILTER_OUTGOING = '~/.tmda/filters/outgoing'

# FILTER_BOUNCE_CC
# An optional e-mail address which will be sent a copy of any message
# that bounces because of a match in FILTER_INCOMING.
#
# Example:
# FILTER_BOUNCE_CC = 'jdoe-bounces@domain.dom'
#
#FILTER_BOUNCE_CC = None

# FILTER_DROP_CC
# An optional e-mail address which will be sent a copy of any message
# that is dropped because of a match in FILTER_INCOMING.
#
# Example:
# FILTER_DROP_CC = 'jdoe-drops@domain.dom'
#
#FILTER_DROP_CC = None

# ACTION_HEADER_INCOMING
# Set this variable to True if you want TMDA to add an 'X-TMDA-Action'
# header to your delivered incoming messages. The value of this header
# is the same as the 'Actn:' field in a LOGFILE_INCOMING entry. e.g,
#
# X-TMDA-Action: OK (from johndoe* ok)
#
# NOTE: This will not work if you are running qmail and have not set
# the DELIVERY variable.
#
#ACTION_HEADER_INCOMING = False

# ACTION_INCOMING
# Specifies how incoming messages should be disposed of by default if
# they didn't match FILTER_INCOMING and were not sent to a tagged
# address.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_incoming.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_INCOMING = 'confirm'

# ACTION_FAIL_DATED
# Specifies how incoming messages should be disposed of if they are sent
# to a dated address that does not properly verify.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_fail_dated.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_FAIL_DATED = 'confirm'

# ACTION_EXPIRED_DATED
# Specifies how incoming messages should be disposed of if they are
# sent to an expired dated address. You can specify a single action to
# take by setting this variable to a string, in which case possible
# values include:
#  'bounce'
#    bounce the message - uses the bounce_expired_dated.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
# This can also be a dictionary if you want to handle different ages
# of expired dated messages in different ways.
#
# Examples:
# ACTION_EXPIRED_DATED = {
#     'default':'confirm', # default is to confirm, unless
#     '1w':     'bounce',  # ...it expired more than 1w ago, then bounce
#     '30d':    'hold',    # ...it expired more than 30d ago, then hold
#     '1Y':     'drop'}    # ...it expired more than 1Y ago, then drop
#
#ACTION_EXPIRED_DATED = 'confirm'

# ACTION_FAIL_SENDER
# Specifies how incoming messages should be disposed of if they are sent
# to a sender address, but were not sent from the correct sender, and
# fail to verify.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_fail_sender.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_FAIL_SENDER = 'confirm'

# ACTION_FAIL_KEYWORD
# Specifies how incoming messages should be disposed of if they are
# sent to a keyword address that fails to verify.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_fail_keyword.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_FAIL_KEYWORD = 'confirm'

# ACTION_INVALID_CONFIRMATION
# Specifies how confirmation messages should be disposed of if they
# are sent to a confirmation address that fails to verify.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_invalid_confirmation.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_INVALID_CONFIRMATION = 'bounce'

# ACTION_MISSING_PENDING
# Specifies how confirmation messages should be disposed of if the
# message to be confirmed can not be located on disk. This might be
# the case if you hand-released the message before the sender tried to
# confirm it by e-mail, or if the sender sent multiple confirmation
# replies.
#
# Possible values include:
#  'bounce'
#    bounce the message - uses the bounce_missing_pending.txt template.
#  'drop'
#    silently drop the message
#  'ok'
#    deliver the message
#  'confirm'
#    request confirmation for the message
#  'hold'
#    silently hold message in pending queue
#
#ACTION_MISSING_PENDING = 'bounce'

# ACTION_OUTGOING
# Specifies how outgoing messages should be tagged by default if there
# are no matches in FILTER_OUTGOING and no X-TMDA header.
#
# Possible values include:
#  'bare[=append]'
#    don't tag
#  'dated[=timeout_interval]'
#    tag with a dated address
#  'sender[=sender_address]'
#    tag with a sender address
#  'exp=full_address'
#    tag with explicit address
#  'kw=keyword'
#    tag with a keyword address
#
#ACTION_OUTGOING = 'dated'

# FINGERPRINT
# A list containing one or more message headers whose values should be
# used to create a "fingerprint" for the message. If the header value
# is 'body' (all-lowercase), the message body content is used instead
# of a header value. The fingerprint is a HMAC digest, using HMAC_ALGO,
# represented as a base64-encoded string. This fingerprint will be
# added to your outgoing client-side messages (i.e, messages sent with
# tmda-sendmail) in an 'X-TMDA-Fingerprint' header prior to injection.
#
# Examples:
# FINGERPRINT = ['message-id']
# FINGERPRINT = ['message-id', 'from', 'date']
# FINGERPRINT = ['message-id', 'body']
#
# Things to keep in mind, especially if verifying these fingerprints
# with non-TMDA code.
#
# * CRYPT_KEY is converted from hex into raw binary before it is
#   used to create the HMAC object.
# * The order of header names in the FINGERPRINT list is important;
#   updates are made in the order listed.
# * If a listed header doesn't exist in the message, no update attempt
#   will be made for that header.
# * For a listed header, only the header value (i.e, text after the
#   colon) is used. Additionally, leading and trailing whitespace (but
#   not internal whitespace) is stripped from that value.
#
# For example, if the listed headers consisted of:
#
# Message-ID: <20011212192455.A7060@nightshade.la.mastaler.com>
# From: "Jason R. Mastaler" <jason-dated-1008901496.5356ec@mastaler.com>
# Date: Wed, 12 Dec 2001 19:24:55 -0700
#
# The strings which are used to create the HMAC digest are the header
# values only (right hand side of Header:).
#
# The following header would then be added to the outgoing message:
#
# X-TMDA-Fingerprint: RosHVeKk7RxuFw9vi26R6w07MmC+LyBngj0i/Ty34mk
#
#FINGERPRINT = None

# FULLNAME
# Your full name.
#
# Example:
# FULLNAME = 'John Doe'
#
#FULLNAME = Util.getfullname()  # GECOS

# HMAC_ALGO
# The algorithm to use to obtain the HMAC, as a string compatible with
# hashlib.new(). If prefixed with a leading 'p2', PBKDF2 iterative
# derivation function will be used along the chosen HMAC algorithm,
# using 10^HMAC_ROUNDS rounds.
#
# CHANGING THIS VALUE WILL INVALIDATE ALL PREVIOUSLY GENERATED HMACs!
#
#HMAC_ALGO = 'p2sha256'

# HMAC_ROUNDS
# An integer which determines the quantity of iterative rounds for PBKDF2
# algorithms, as a power of 10; e.g. 5 => 10^5 = 100'000 rounds.
#
# CHANGING THIS VALUE WILL INVALIDATE ALL PREVIOUSLY GENERATED HMACs!
#
#HMAC_ROUNDS = 5

# HMAC_BYTES
# An integer which determines the length of the HMACs used in TMDA's
# "cookies". Read the 'CRYPTO' file for more information.
#
# CHANGING THIS VALUE WILL INVALIDATE ALL PREVIOUSLY GENERATED HMACs!
#
#HMAC_BYTES = 5

# HMAC_ENCODING_COMPAT
# A boolean that enables legacy (hexadecimal) HMAC encoding compatibility.
# This should be enabled only when upgrading from TMDA < 1.3 and hexadecimal
# encoded HMAC/addresses are still being used.  After a key rollover - and
# taking care no hexadecimal HMAC are being used as a result of collision
# with the new aplhanumeric encoding - this setting can be set back to False.
#
#HMAC_ENCODING_COMPAT = False

# HOSTNAME
# The right-hand side of your email address (after '@'). Used only in
# cases where TMDA can't determine this itself.
#
# Example:
# HOSTNAME = 'domain.dom'
#
#HOSTNAME = Util.gethostname()  # hostname -f

# LOGFILE_DEBUG
# Filename which uncaught exceptions should be written to.
#
# Examples:
# LOGFILE_DEBUG = '/path/to/logs/tmda.debug'
# LOGFILE_DEBUG = '~/.tmda/logs/debug'
#
#LOGFILE_DEBUG = None

# LOGFILE_INCOMING
# Filename which incoming delivery (i.e, tmda-filter) summaries should
# be written to.
#
# Examples:
# LOGFILE_INCOMING = '/path/to/logs/tmda.in'
# LOGFILE_INCOMING = '~/.tmda/logs/incoming'
#
#LOGFILE_INCOMING = None

# LOGFILE_OUTGOING
# Filename which outgoing message (i.e, tmda-sendmail) summaries
# should be written to.
#
# Examples:
# LOGFILE_OUTGOING = '/path/to/logs/tmda.out'
# LOGFILE_OUTGOING = '~/.tmda/logs/outgoing'
#
#LOGFILE_OUTGOING = None

# MESSAGE_FROM_STYLE
# Specifies how 'From' and 'Resent-From' headers should look when
# tagging outgoing messages with tmda-sendmail.
#
# There are two valid values:
#  'address'
#    Just the address - king@grassland.com
#  'angles'
#    Elvis Parsley <king@grassland.com>
#
#MESSAGE_FROM_STYLE = 'angles'

# MESSAGE_TAG_HEADER_STYLE
# Specifies how headers (other than 'From' and 'Resent-From') should
# look when tagging outgoing messages with tmda-sendmail. These are
# the headers such as Reply-To which are defined using the 'tag'
# action in your FILTER_OUTGOING file.
#
# The valid values and default value is identical to that of
# MESSAGE_FROM_STYLE.
#
#MESSAGE_TAG_HEADER_STYLE = 'angles'

# MAX_AUTORESPONSES_PER_DAY
# An integer specifying the maximum number of automatic responses sent
# to a given sender address in a day. This includes _all_
# auto-responses sent by TMDA (confirmation requests, confirmation
# acceptance notices, failure notices, etc.)
#
# This limit prevents response loops between TMDA and misconfigured
# remote auto-responders. TMDA already inhibits automatic replies to
# any message that looks like a mailing list message or a bounce
# message. This is a fallback safety valve so it should be set fairly
# high. Set to 0 for no limit.
#
#MAX_AUTORESPONSES_PER_DAY = 50

# RESPONSE_DIR
# Full path to a directory containing auto-response rate-limiting
# information. Only consulted if MAX_AUTORESPONSES_PER_DAY != 0
#
#RESPONSE_DIR = '~/.tmda/responses'

# AUTORESPONSE_INCLUDE_SENDER_COPY
# An integer which controls whether a copy of the sender's message is
# included or not when sending an auto response. Available options:
#
# 0 - do not include any portion of the sender's message.
# 1 - include only the headers from the sender's message.
# 2 - include the sender's entire message.
#
# 2 is *highly* recommended. Not only to give the sender a clear
# indication of which message is being responded to, but also to
# preserve the message for the sender in case she didn't save a copy
# when sending it.
#
#AUTORESPONSE_INCLUDE_SENDER_COPY = 2

# DB_CONNECTION
# Python DB API Connection object. This is specific to the database
# and should be created in the ~/.tmda/config file. This is typically
# created by importing the appropriate module and calling the connect()
# function.
#
# Example:
# import MySQLdb
# DB_CONNECTION = MySQLdb.connect('...')
#
#DB_CONNECTION = None

# DB_CONFIRM_APPEND
# SQL INSERT statement to be used to insert confirmed sender addresses
# into a SQL database. The Python DB API will take care of properly
# quoting parameters that are strings.
# Requires a valid DB_CONNECTION object.
#
# Available substition parameters are:
#  %(recipient)s  - USERNAME@HOSTNAME
#  %(username)s   - USERNAME
#  %(hostname)s   - HOSTNAME
#  %(sender)s     - sender's address (envelope sender or X-Primary-Address)
#
# Examples:
# DB_CONFIRM_APPEND = """
#   INSERT INTO whitelist (user_email, address)
#     VALUES (%(recipient)s, %(sender)s)"""
# DB_CONFIRM_APPEND = """
#   INSERT INTO wildcard_list (uid, address, action)
#     SELECT uid, %(sender)s, 'accept'
#     FROM users
#     WHERE users.email = %(recipient)s"""
#
#DB_CONFIRM_APPEND = None

# DB_BARE_APPEND
# SQL INSERT statement to be used to insert recipient addresses into
# a SQL database if the outgoing <action> was 'bare=append'. The Python
# DB API will take care of properly quoting parameters that are strings.
# Requires a valid DB_CONNECTION object.
#
# Available substition parameters are:
#  %(recipient)s  - recipient's email address
#  %(username)s   - USERNAME (of TMDA user)
#  %(hostname)s   - HOSTNAME (of TMDA user)
#  %(sender)s     - USERNAME@HOSTNAME (address of TMDA user)
#  %(fromheader)s - address of TMDA user in From: header field
#
# Examples:
# DB_BARE_APPEND = """
#   INSERT INTO whitelist (user_email, address)
#     VALUES (%(sender)s, %(recipient)s)"""
#
#DB_BARE_APPEND = None

# PENDING_DIR
# Full path to the directory containing messages pending confirmation
# (aka, the "pending queue"). If this directory doesn't exist, it
# will automatically be created by TMDA with 0700 permissions when the
# first message arrives.
#
#PENDING_DIR = '~/.tmda/pending'

# PENDING_QUEUE_FORMAT
# A string specifying the format of TMDA's pending queue where
# unconfirmed messages are stored.
#
# Possible values include:
#  'original'
#    A custom TMDA format where messages are stored one per file in a
#    directory (PENDING_DIR). Offers high performance, but can only
#    be browsed with TMDA tools like 'tmda-pending' and 'tmda-cgi'.
#  'maildir'
#    Maildir is a specific one-file-per-message organization that
#    was introduced with the qmail system by D.J. Bernstein. For
#    more information, see http://wiki.tmda.net/TmdaPendingAsMaildir
#
#PENDING_QUEUE_FORMAT = 'original'

# PENDING_LIFETIME
# A time interval describing how long a message can live in the
# pending queue before it's subject to automated deletion by
# tmda-filter (a feature controlled by the PENDING_CLEANUP_ODDS
# setting).
#
# Time intervals can be expressed in seconds (s), minutes (m), hours
# (h), days (d), weeks (w), months (M), or years (Y).
#
# Examples:
# PENDING_LIFETIME = '24h' # messages can live for 24 hours
# PENDING_LIFETIME = '1M'  # messages can live for 1 month
#
#PENDING_LIFETIME = '14d'

# PENDING_CLEANUP_ODDS
# A floating point number which describes the odds that tmda-filter
# will automatically clean the pending queue of expired messages upon
# receipt of an incoming message. The lifetime of a message in the
# pending queue is controlled by the PENDING_LIFETIME setting.
#
# If you wish to disable this feature in order to clean the queue by
# hand, or through cron, set this value to 0.0. If you wish to
# trigger a cleanup every time a message arrives, set it to 1.0.
#
# The closer this value gets to 1.0, the fewer messages you'll have in
# your pending queue beyond PENDING_LIFETIME, but at some additional
# expense upon delivery.
#
# Examples:
# PENDING_CLEANUP_ODDS = 0.0   # 0% chance
# PENDING_CLEANUP_ODDS = 1.0   # 100% chance
# PENDING_CLEANUP_ODDS = 0.025 # 2.5% chance
#
#PENDING_CLEANUP_ODDS = 0.01

# PENDING_CACHE
# Path to the cache file used when tmda-pending is invoked with the
# --cache option.
#
#PENDING_CACHE = '~/.tmda/.pendingcache'

# PENDING_CACHE_LEN
# An integer which specifies the maximum number of entries held by
# PENDING_CACHE. Make sure this is greater than the number of
# messages kept in your pending queue, or else you'll start seeing
# previously viewed messages again.
#
#PENDING_CACHE_LEN = 5000

# PENDING_BLACKLIST_APPEND
# Filename to which a sender's e-mail address should be appended
# when a message is "blacklisted" by tmda-pending.
#
# Examples:
# PENDING_BLACKLIST_APPEND = '/full/path/to/blacklist'
# PENDING_BLACKLIST_APPEND = '~/.tmda/lists/blacklist'
#
#PENDING_BLACKLIST_APPEND = None

# DB_PENDING_BLACKLIST_APPEND
# SQL INSERT statement to be used to insert blacklisted sender addresses
# into a SQL database. The Python DB API will take care of properly
# quoting parameters that are strings.
#
# Requires a valid DB_CONNECTION object.
#
# Available substitution parameters are:
#  %(recipient)s  - USERNAME@HOSTNAME
#  %(username)s   - USERNAME
#  %(hostname)s   - HOSTNAME
#  %(sender)s     - sender's address (envelope sender or X-Primary-Address)
#
# Examples:
# DB_PENDING_BLACKLIST_APPEND = """
#   INSERT INTO blacklist (user_email, address)
#     VALUES (%(recipient)s, %(sender)s)"""
# DB_PENDING_BLACKLIST_APPEND = """
#   INSERT INTO wildcard_list (uid, address, action)
#     SELECT uid, %(sender)s, 'drop'
#     FROM users
#     WHERE users.email = %(recipient)s"""
#
#DB_PENDING_BLACKLIST_APPEND = None

# PENDING_DELETE_APPEND
# Filename to which a sender's e-mail address should be automatically
# appended when a message is "deleted" by tmda-pending. tmda-filter's
# automated pending queue cleanup feature (see PENDING_CLEANUP_ODDS)
# also respects this setting.
#
# Examples:
# PENDING_DELETE_APPEND = '/full/path/to/blacklist'
# PENDING_DELETE_APPEND = '~/.tmda/lists/blacklist'
#
#PENDING_DELETE_APPEND = None

# DB_PENDING_DELETE_APPEND
# SQL INSERT statement to be used to insert deleted sender addresses
# into a SQL database. The Python DB API will take care of properly
# quoting parameters that are strings.
#
# Requires a valid DB_CONNECTION object.
#
# Available substitution parameters are:
#  %(recipient)s  - USERNAME@HOSTNAME
#  %(username)s   - USERNAME
#  %(hostname)s   - HOSTNAME
#  %(sender)s     - sender's address (envelope sender or X-Primary-Address)
#
# Examples:
# DB_PENDING_DELETE_APPEND = """
#   INSERT INTO blacklist (user_email, address)
#     VALUES (%(recipient)s, %(sender)s)"""
# DB_PENDING_DELETE_APPEND = """
#   INSERT INTO wildcard_list (uid, address, action)
#     SELECT uid, %(sender)s, 'confirm'
#     FROM users
#     WHERE users.email = %(recipient)s"""
#
#DB_PENDING_DELETE_APPEND = None

# PENDING_RELEASE_APPEND
# Filename to which a sender's e-mail address should be automatically
# appended when a message is "released" by tmda-pending.
#
# Examples:
# PENDING_RELEASE_APPEND = '/full/path/to/whitelist'
# PENDING_RELEASE_APPEND = '~/.tmda/lists/whitelist'
#
#PENDING_RELEASE_APPEND = None

# DB_PENDING_RELEASE_APPEND
# SQL INSERT statement to be used to insert released sender addresses
# into a SQL database. The Python DB API will take care of properly
# quoting parameters that are strings.
#
# Requires a valid DB_CONNECTION object.
#
# Available substitution parameters are:
#  %(recipient)s  - USERNAME@HOSTNAME
#  %(username)s   - USERNAME
#  %(hostname)s   - HOSTNAME
#  %(sender)s     - sender's address (envelope sender or X-Primary-Address)
#
# Examples:
# DB_PENDING_RELEASE_APPEND = """
#   INSERT INTO whitelist (user_email, address)
#     VALUES (%(recipient)s, %(sender)s)"""
# DB_PENDING_RELEASE_APPEND = """
#   INSERT INTO wildcard_list (uid, address, action)
#     SELECT uid, %(sender)s, 'accept'
#     FROM users
#     WHERE users.email = %(recipient)s"""
#
#DB_PENDING_RELEASE_APPEND = None

# PENDING_WHITELIST_APPEND
# Filename to which a sender's e-mail address should be appended
# when a message is "whitelisted" by tmda-pending.
#
# Examples:
# PENDING_WHITELIST_APPEND = '/full/path/to/whitelist'
# PENDING_WHITELIST_APPEND = '~/.tmda/lists/whitelist'
#
#PENDING_WHITELIST_APPEND = None

# DB_PENDING_WHITELIST_APPEND
# SQL INSERT statement to be used to insert whitelisted sender addresses
# into a SQL database. The Python DB API will take care of properly
# quoting parameters that are strings.
#
# Requires a valid DB_CONNECTION object.
#
# Available substitution parameters are:
#  %(recipient)s  - USERNAME@HOSTNAME
#  %(username)s   - USERNAME
#  %(hostname)s   - HOSTNAME
#  %(sender)s     - sender's address (envelope sender or X-Primary-Address)
#
# Examples:
# DB_PENDING_WHITELIST_APPEND = """
#   INSERT INTO whitelist (user_email, address)
#     VALUES (%(recipient)s, %(sender)s)"""
# DB_PENDING_WHITELIST_APPEND = """
#   INSERT INTO wildcard_list (uid, address, action)
#     SELECT uid, %(sender)s, 'accept'
#     FROM users
#     WHERE users.email = %(recipient)s"""
#
#DB_PENDING_WHITELIST_APPEND = None

# PENDING_WHITELIST_RELEASE
# An option detailing the action taken when 'Whitelist' is the
# current action in tmda-pending or tmda-cgi
#
# Available options:
#  0 - 'Whitelist' does not release any messages, only appends
#      the envelope sender to PENDING_WHITELIST_APPEND
#  1 - 'Whitelist' releases the current message and also appends
#      the envelope sender to PENDING_WHITELIST_APPEND
#
#PENDING_WHITELIST_RELEASE = 1

# ADDED_HEADERS_CLIENT
# A Python dictionary containing one or more header:value string pairs
# that should be added to _all_ outgoing client-side messages (i.e,
# messages sent with tmda-sendmail) prior to injection. Listed
# headers and their values are case-sensitive.
#
# As the examples below illustrate, the full power of Python is
# available to create these headers -- just make sure both the header
# and its value end up as strings.
#
# Examples:
# ADDED_HEADERS_CLIENT = {'X-Fact' : 'Father Hennepin Discovered Niagra Falls'}
# import time, os, random
# ADDED_HEADERS_CLIENT = {
#     'X-Localtime' : time.asctime(),
#     'X-Favorite-Author' : 'James Joyce',
#     'X-OperatingSystem' : os.uname()[0],
#     'Organization' : os.environ.get('ORGANIZATION'),
#     'X-Uptime' : os.popen('/usr/bin/uptime').read().strip(),
#     'X-Now-Reading' : random.choice(open
#                                     ('/home/jasonrm/.now-reading').
#                                     readlines()).strip()
#     }
#
#ADDED_HEADERS_CLIENT = None

# ADDED_HEADERS_SERVER
# A Python dictionary containing one or more header:value string pairs
# that should be added to _all_ outgoing server-side messages (i.e,
# messages sent with tmda-filter) prior to injection. Listed
# headers and their values are case-sensitive.
#
# See ADDED_HEADERS_CLIENT (above) for some examples.
#
#ADDED_HEADERS_SERVER = None

# PRIMARY_ADDRESS_MATCH
# An integer which controls how closely the address in the
# 'X-Primary-Address' header of an incoming messages must match the
# envelope sender address before it's honored.
#
# If the match is close enough, this address will be used for
# CONFIRM_APPEND instead of the envelope sender, and also added to the
# list of addresses checked against FILTER_INCOMING.
#
# This option is available to limit cases of abuse where a sender
# attempts to "whitelist" an address not his own by using an external
# address in an 'X-Primary-Address' header.
#
# Available options:
#  0 - Never a match. Equivalent to disabling X-Primary-Address recognition.
#  1 - Identical addresses match. e.g, king@grassland.com and
#      king@grassland.com.
#  2 - Usernames and hostnames must match. e.g, king@grassland.com and
#      king-dated-1037839131.65d080@grassland.com.
#  3 - Usernames and domains must match. e.g, king@grassland.com and
#      king-dated-1037839131.65d080@memphis.grassland.com.
#  4 - Hostnames must match. e.g, king@grassland.com and
#      elvis@grassland.com.
#  5 - Domains must match. e.g, king@grassland.com and
#      elvis@memphis.grassland.com.
#  6 - Always a match. e.g, king@grassland.com and elvis@parsely.com.
#
#PRIMARY_ADDRESS_MATCH = 5

# PURGED_HEADERS_CLIENT
# A list containing one or more message headers that should be removed
# from outgoing client-side messages (i.e, messages sent with
# tmda-sendmail) prior to injection. Listed headers are
# case-insensitive, and the purging will only be attempted if the
# header actually exists.
#
# NOTE: PURGED_HEADERS_CLIENT is run _after_ ADDED_HEADERS (see above).
#
# Examples:
# PURGED_HEADERS_CLIENT = ['bcc', 'resent-bcc', 'x-mailer']
# PURGED_HEADERS_CLIENT = ['bcc', 'resent-bcc', 'x-mailer', 'user-agent']
#
#PURGED_HEADERS_CLIENT = ['bcc', 'resent-bcc']

# PURGED_HEADERS_SERVER
# A list containing one or more message headers that should be removed
# from _all_ outgoing server-side messages (i.e, messages sent with
# tmda-filter) prior to injection. Listed headers are case-insensitive
# and the purging will only be attempted if the header actually exists.
#
# See PURGED_HEADERS_CLIENT (above) for some examples.
#
#PURGED_HEADERS_SERVER = None

# PURGED_HEADERS_DELIVERY
# A list containing one or more message headers that should be removed
# from _all_ delivered messages (i.e, messages stored in an mbox or a
# maildir, forwarded or passed to a program by TMDA). Listed headers
# are case-insensitive and the purging will only be attempted if the
# header actually exists.
#
# See PURGED_HEADERS_CLIENT (above) for some examples.
#
#PURGED_HEADERS_DELIVERY = None

# RECIPIENT_HEADER
# A string containing the name of a header (case-insensitive) whose
# contents will be taken as the envelope recipient of the message.
# The header should contain one fully-qualified e-mail address. This
# can be used in rare cases when you need to override the RECIPIENT
# environment variable, which is how TMDA normally determines the
# envelope recipient address. If EXT isn't set, the address extension
# will also be extracted from RECIPIENT_HEADER.
#
# Example:
# RECIPIENT_HEADER = 'x-originally-to'
#
# Then, if the message contains the following header:
#
# X-Originally-To: webmaster@domain.dom
#
# TMDA will take webmaster@domain.dom as the envelope recipient of the
# message rather than the value of RECIPIENT.
#
# WARNING: If you enable this feature, make sure that the method you
# are using to add the header will overwrite or replace an existing
# header of the same name (such as reformail/formail's -i and -I
# options do). Otherwise the envelope recipient will be invalid which
# will break the confirmation process.
#
#RECIPIENT_HEADER = None

# TAGS_CONFIRM
# A list of one or more strings used to identify a confirmation
# address. The first element in the list will be used when
# generating a new confirmation address.
#
# Example:
# TAGS_CONFIRM = ['confirm', 'c']
#
#TAGS_CONFIRM = ['confirm']

# TAGS_DATED
# A list of one or more strings used to identify a dated address. The
# first element in the list will be used by 'tmda-address' when
# generating a new dated address.
#
# Example:
# TAGS_DATED = ['dated', 'd', 'exp', 'expires']
#
#TAGS_DATED = ['dated']

# TAGS_KEYWORD
# A list of one or more strings used to identify a keyword address.
# The first element in the list will be used by 'tmda-address' when
# generating a new keyword address.
#
# Example:
# TAGS_KEYWORD = ['keyword', 'key', 'kw']
#
#TAGS_KEYWORD = ['keyword']

# TAGS_SENDER
# A list of one or more strings to identify a sender address. The
# first element in the list will be used by 'tmda-address' when
# generating a new sender address.
#
# Example:
# TAGS_SENDER = ['sender', 's']
#
#TAGS_SENDER = ['sender']

# TERSE_SUMMARY_HEADERS
# A list containing one or more message headers that should be
# displayed by tmda-pending's '--terse option'. Listed headers are
# case-insensitive. 'from_name' and 'from_address' can be used to
# specify the Fullname and e-mail address from the message's "From:"
# header.
#
# Examples:
# TERSE_SUMMARY_HEADERS = ['return-path']
# TERSE_SUMMARY_HEADERS = ['from_name', 'from_address', 'subject']
#
#TERSE_SUMMARY_HEADERS = ['from_name', 'subject']

# TMDAINJECT
# A string containing one or more of the following letters which toggle
# on certain behaviors in tmda-inject (which is used by both
# tmda-sendmail and tmda-ofmipd):
#  'd' - Add a new Date field to the message, clobbering any
#        existing Date fields. Normally tmda-inject only adds a
#        Date field if the incoming message lacks one.
#  'i' - Add a new Message-ID field to the message, clobbering any
#        existing Message-ID fields. Normally tmda-inject only adds a
#        Message-ID field if the incoming message lacks one.
#
# Examples:
# TMDAINJECT = 'i'
# TMDAINJECT = 'di'
#
#TMDAINJECT = None

# MAIL_FOLLOWUP_TO
# Inspired by qmail-inject's QMAILMFTFILE feature, MAIL_FOLLOWUP_TO
# automatically adds a Mail-Followup-To field for messages sent to
# mailing lists. It works for both tmda-sendmail and tmda-ofmipd.
#
# MAIL_FOLLOWUP_TO can either be a list of mailing list addresses, or
# a string pointing to a file containing mailing list addresses, one
# per line. If To or Cc in the message includes one of those
# addresses (without regard to case), tmda-inject adds a
# Mail-Followup-To field with all the To+Cc addresses. tmda-inject
# does not add Mail-Followup-To to a message that already has one, or
# if the address file does not exist.
#
# See http://cr.yp.to/proto/replyto.html for more on Mail-Followup-To.
#
# Examples:
# MAIL_FOLLOWUP_TO = '/path/to/lists.txt'
# MAIL_FOLLOWUP_TO = '~/.lists'
# MAIL_FOLLOWUP_TO = ['tmda-users@tmda.net', 'postfix-users@postfix.org']
#
#MAIL_FOLLOWUP_TO = None

# SUMMARY_HEADERS
# A list containing one or more message headers that should be
# displayed by tmda-pending's interactive mode. Listed headers are
# case-insensitive.
#
# Examples:
# SUMMARY_HEADERS = ['from', 'subject', 'x-spam-status']
# SUMMARY_HEADERS = ['date', 'from', 'to', 'subject']
#
#SUMMARY_HEADERS = ['date', 'from', 'to', 'subject']

# DATED_TIMEOUT
# The timeout interval for 'dated' addresses. The available units are
# (Y=years, M=months, w=weeks, d=days, h=hours, m=minutes, s=seconds).
#
#DATED_TIMEOUT = '5d'

# USERNAME
# The left-hand side of your e-mail address (before '@').
#
# Example:
# USERNAME = 'jdoe'
#
#USERNAME = Util.getusername()  # whoami

# TIMEOUT_UNITS
# Dictionary that contains translations of timeout unit strings. This
# dictionary must contains the keys Y,M,w,d,h,m,s with respective
# internationalized strings as values.
#
# Examples:
# TIMEOUT_UNITS = {
#       'Y' : 'anos',
#       'M' : 'meses',
#       'w' : 'semanas',
#       'd' : 'dias',
#       'h' : 'horas',
#       'm' : 'minutos',
#       's' : 'segundos'}
#
#TIMEOUT_UNITS = {
#    'Y' : 'years',
#    'M' : 'months',
#    'w' : 'weeks',
#    'd' : 'days',
#    'h' : 'hours',
#    'm' : 'minutes',
#    's' : 'seconds'
#}

# X_TMDA_IN_SUBJECT
# With this variable set to True, tmda-inject will parse the Subject
# header looking for 'X-TMDA' actions, and then remove them before
# sending the message. This is useful for users that desire the
# 'X-TMDA' override behavior, but don't use an MUA which easily allows
# addition of arbitrary headers (e.g, Outlook).
#
# The Subject header should contain 'X-TMDA' followed by whitespace
# followed by the desired action followed by the real subject. Case
# is insensitive.
#
# Examples:
# Subject: X-TMDA dated Re: You're fired!
# Subject: X-TMDA dated=5M Re: You're fired!
# Subject: X-TMDA sender Re: You're fired!
#
# In all cases, the resulting subject will simply be:
#
# Subject: Re: You're fired!
#
#X_TMDA_IN_SUBJECT = False

# CRYPT_KEY_FILE
# File which contains your unique TMDA secret key generated by the
# 'tmda-keygen' program. The key should be unquoted in the file.
# This file must be chmod 400 or 600, unless ALLOW_MODE_640 is on.
#
#CRYPT_KEY_FILE = '~/.tmda/crypt_key'

# CRYPT_KEY_FILE_ROLLOVER
# File which contains your PREVIOUS ("rolled-over-from") TMDA secret key.
# If defined, TMDA will fallback to verify tagged addresses using this
# key in case the current key (as per CRYPT_KEY_FILE) fails.
# Also see the HMAC_ALGO_ROLLOVER, HMAC_ROUNDS_ROLLOVER and HMAC_BYTES_ROLLOVER
# settings below.
#
#CRYPT_KEY_FILE_ROLLOVER = None

# HMAC_ALGO_ROLLOVER
# Rollover equivalent of HMAC_ALGO.
# See CRYPTO_KEY_FILE_ROLLOVER for details.
# The "legacy" (older TMDA) algorithm was 'sha1'.
#
#HMAC_ALGO_ROLLOVER = HMAC_ALGO

# HMAC_ROUNDS_ROLLOVER
# Rollover equivalent of HMAC_ALGO.
# See CRYPTO_KEY_FILE_ROLLOVER for details.
#
#HMAC_ROUNDS_ROLLOVER = HMAC_ROUNDS

# HMAC_BYTES_ROLLOVER
# Rollover equivalent of HMAC_BYTES.
# See CRYPTO_KEY_FILE_ROLLOVER for details.
# The "legacy" (older TMDA) default value was 3.
#
#HMAC_BYTES_ROLLOVER = HMAC_BYTES


## Debian-specific

# New files permissions
os.umask(0o077)

# WARNING! File permissions issues!
# When started by systemd, tmda-ofmipd runs with tmdad:mail (non-root!) 
# privileges. Users resources permissions MUST be carefully adjusted!
#  chmod -R go= ${DATADIR}
#  chgrp -R mail ${DATADIR}
#  find ${DATADIR} -type d -exec chmod g+s {} \;
#  chmod g+r ${DATADIR}/config ${CRYPT_KEY_FILE}
#  chmod g+rw ${LOGFILE_OUTGOING} ${BARE_APPEND}
#ALLOW_MODE_640=1
